console.log("=======시작!!!!=======");
console.log("aaa-시작");
console.log("bbb-시작");
console.log(friend);
console.log("aaa-끝");
console.log("=======끝!!!!=======");


이런 순서로 찍힐 거 같은데??

아님......

정답은....

=======시작!!!!=======
aaa-시작
bbb-시작
aaa-끝
=======끝!!!!=======
철수

이렇게 찍힌다.


왜?????

우리가 await를 만나게 되면, (await "철수"; 이 부분)
기다려야 된다!를 확 느낌. 스레드가.

그러면 await "철수"; 이거,
다 끝나고 처리해야겠다. 하고
async function bbb() {}
이거를 통채로 마이크로 큐에 넣어버린다.
잠깐 쉬어~~ 하고.

[중요] await "철수"; 에서, await 과 "철수" 는 따로 봐야 함.
"철수"를 먼저 보고, 실행한다.
만약 "철수" 가 일반 문자열이 아니라 함수였으면, 그 함수를 먼저 들어가서 수행한다.
"철수" 수행 완료(그냥 문자열이라 별 것 없음.), 그 다음 await를 만난다.
아, 오래 걸리겠네.
"철수" 를 임시 저장한다. (변수 friend에 넣지 않고,)
--> bbb()를 통째로 마이크로 큐로 보냄.

콜스택: onClickLoop(), aaa(), bbb()
마이크로큐: bbb()의 현재까지 수행한 상태(변수 friend에 넣지 않은 딱 그 상태)

이 상태에서 콜스택에서 하나씩 빠짐.
bbb() 빠짐 --> aaa() 로 다시 돌아옴. --> aaa-끝 찍힘.
aaa() 빠짐 --> onClickLoop() 로 다시 돌아옴 --> =======끝!!!!======= 찍힘.
onClickLoop() 빠짐 --> 함수 종료됨.

이제 뭐 할 게 없네? 어? 마이크로큐에 뭐가 있잖아?
bbb()의 현재상태임시저장 이 있잖아?
bbb() 꺼냄 --> 임시저장 해제, 계속해서 진행
--> 변수 friend에 담기 --> "철수" 로그 찍기

그래서 마지막에 "철수" 가 찍히는 것이다.
그래서 함수에 async 를 붙이는 것이다.
짝꿍으로.
await 랑 짝꿍 되서 마이크로 큐에 들어가는 함수라고 표시하는 것이다.